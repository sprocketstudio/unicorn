{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"gradient","usesPingPong":false,"speed":0.25,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) { switch(index) { case 0: return vec3(0.03529411764705882, 0.03529411764705882, 0.047058823529411764); case 1: return vec3(0, 0, 0); case 2: return vec3(0, 0, 0); case 3: return vec3(0, 0, 0); case 4: return vec3(0, 0, 0); case 5: return vec3(0, 0, 0); case 6: return vec3(0, 0, 0); case 7: return vec3(0, 0, 0); case 8: return vec3(0, 0, 0); case 9: return vec3(0, 0, 0); case 10: return vec3(0, 0, 0); case 11: return vec3(0, 0, 0); case 12: return vec3(0, 0, 0); case 13: return vec3(0, 0, 0); case 14: return vec3(0, 0, 0); case 15: return vec3(0, 0, 0); default: return vec3(0.0); } }const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) { float s = sin(angle); float c = cos(angle); return vec2( coord.x * c - coord.y * s, coord.x * s + coord.y * c ); }out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0.03529411764705882, 0.03529411764705882, 0.047058823529411764); }void main() {vec2 uv = vTextureCoord; vec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000); uv -= pos; uv /= (0.5000*2.); uv = rotate(uv, (0.0000 - 0.5) * 2. * PI); vec4 color = vec4(getColor(uv), 1.); fragColor = color; }"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = aTextureCoord; }"],"data":{"downSample":0.5,"depth":false,"uniforms":{},"isBackground":true},"id":"effect"},{"breakpoints":[{"max":null,"name":"Desktop","min":992,"props":{"trackMouse":0.005,"attraction":0.14}},{"name":"Tablet","max":991,"min":576,"props":{"trackMouse":0,"attraction":0}}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"wisps","usesPingPong":false,"speed":0.01,"trackMouse":0.005,"mouseMomentum":1,"texture":false,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uTime; uniform float uAttraction; uniform float uTrackMouse; uniform vec2 uMousePos; uniform vec2 uResolution;out vec4 fragColor; const float PI = 3.14159265359; mat2 rot(float a) { return mat2(cos(a), -sin(a), sin(a), cos(a)); }vec2 hash(vec2 p) { p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3))); return -1.0 + 2.0 * fract(sin(p) * 43758.5453123); }float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }float voronoi_additive(vec2 st, float radius, vec2 mouse_pos, float scale) { vec2 i_st = floor(st); vec2 f_st = fract(st);float wander = 1.0000 * uTime * 0.2; float total_contribution = 0.0;for (int y = -2; y <= 2; y++) { for (int x = -2; x <= 2; x++) { vec2 neighbor = vec2(float(x), float(y)); vec2 cell_id = i_st + neighbor; vec2 point = hash(cell_id); point = 0.5 + 0.5 * sin(5. + wander + 6.2831 * point); vec2 starAbsPos = cell_id + point; vec2 dirToMouse = mouse_pos - starAbsPos; float distToMouse = length(dirToMouse); float attractStrength = uAttraction * exp(-distToMouse * mix(2.0 + 1.0000 * 2., 0.5, 1.0000)) * 2.; starAbsPos += dirToMouse * attractStrength; vec2 diff = starAbsPos - st; float dist = length(diff);float contribution = radius / max(dist, radius * 0.1); float shimmer_phase = dot(point, vec2(1.0)) * 10. + hash(cell_id).x * 5.0 + uTime * 0.5; float shimmer = mix(1., (sin(shimmer_phase) + 1.), 0.1400); contribution *= shimmer; total_contribution += mix(contribution*contribution, contribution * 2., 0.1400); } }return total_contribution; }vec4 randomStyle() { vec2 uv = vTextureCoord;vec4 bg = texture(uTexture, uv);vec4 color = vec4(0.0); vec2 aspectRatio = vec2(uResolution.x / uResolution.y, 1.0);vec2 mPos = mix(vec2(0.0), (uMousePos - 0.5), uTrackMouse);uv -= vec2(0.5, 0.5); uv *= aspectRatio; uv = uv * rot(0.3240 * 2.0 * PI); uv *= 40.0 * 1.0000; uv *= mix(vec2(1.0), vec2(1.0, 0.0), 0.9800); uv /= aspectRatio;mPos = mPos * rot(0.3240 * 2.0 * PI);vec2 mouseGrid = uMousePos; mouseGrid -= vec2(0.5, 0.5); mouseGrid *= aspectRatio; mouseGrid = mouseGrid * rot(0.3240 * 2.0 * PI); mouseGrid *= 40.0 * 1.0000; mouseGrid *= mix(vec2(1.0), vec2(1.0, 0.0), 0.9800); mouseGrid /= aspectRatio;vec2 movementOffset = vec2(0.0, uTime * 1.0000 * -0.05); vec2 mouseGrid1 = mouseGrid - (mPos * 38.0 * 1.0000) + movementOffset; vec2 mouseGrid2 = mouseGrid - (mPos * 48.0 * 1.0000) + movementOffset;vec2 st1 = uv - (mPos * 38.0 * 1.0000); vec2 st2 = uv - (mPos * 48.0 * 1.0000);vec2 mouse1 = st1 + vec2(0.0, uTime * 1.0000 * -0.05); vec2 mouse2 = st2 + vec2(0.0, uTime * 1.0000 * -0.05);float radius1 = 0.5 * 0.4500; float radius2 = 0.5 * 0.4500;float pass1 = voronoi_additive(mouse1 * aspectRatio, radius1, mouseGrid1 * aspectRatio, 38.0 * 1.0000); float pass2 = voronoi_additive(mouse2 * aspectRatio + vec2(10), radius2, mouseGrid2 * aspectRatio + vec2(10.0), 48.0 * 1.0000);pass1 *= 0.02; pass2 *= 0.04;color.rgb = (pass1 + pass2) * vec3(0.12941176470588237, 0.1803921568627451, 0.7529411764705882) * mix(1.0, bg.r, 0.3500); color.rgb = clamp(color.rgb, 0.0, 1.0);color = vec4(color.rgb, max(bg.a, luma(color.rgb))); return color; }void main() { vec4 color;color = randomStyle(); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"trackMouse":{"name":"uTrackMouse","type":"1f","value":0},"attraction":{"name":"uAttraction","type":"1f","value":0}},"isBackground":false},"id":"effect1"},{"breakpoints":[{"name":"Desktop","min":992,"props":{"skew":0.44,"radius":0.28,"falloff":1},"max":null},{"max":991,"name":"Tablet","props":{"radius":0.2,"skew":0.58,"falloff":0.96},"min":576},{"min":0,"props":{"radius":0.24,"falloff":1,"skew":0.65},"max":575,"name":"Mobile"}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"mouseMomentum":1,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform float uRadius; uniform float uFalloff; uniform float uSkew; uniform vec2 uResolution;out vec4 fragColor; mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(uSkew, 1.0 - uSkew); float halfRadius = uRadius * 0.5; float innerEdge = halfRadius - uFalloff * halfRadius * 0.5; float outerEdge = halfRadius + uFalloff * halfRadius * 0.5; vec2 pos = vec2(0.5, 0.5); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); vec3 finalColor;finalColor = mix(color.rgb, mix(color.rgb, vec3(0.03529411764705882, 0.03529411764705882, 0.047058823529411764), 1.0000), falloff); color = mix(color * (1.-falloff), vec4(finalColor * color.a, color.a), 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"radius":{"name":"uRadius","type":"1f","value":0.5},"skew":{"name":"uSkew","type":"1f","value":0.5},"falloff":{"name":"uFalloff","type":"1f","value":1}},"isBackground":false},"id":"effect2"},{"breakpoints":[{"props":{"fov":1,"scale":0.19},"name":"Desktop","min":992,"max":null},{"props":{"scale":0.14,"fov":0.7},"min":576,"max":991,"name":"Tablet"},{"min":0,"name":"Mobile","props":{"fov":0.58,"scale":0.22},"max":575}],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"projection","usesPingPong":false,"trackMouse":0,"mouseMomentum":1,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition; in vec2 vTextureCoord;uniform sampler2D uTexture; uniform float uFov; uniform float uScale; uniform float uTime;uniform vec2 uMousePos;const float PI = 3.14159265;vec3 getRayDirection(vec2 uv, vec2 mousePos, float aspect) { vec2 screenPos = (uv - 0.5) * 2.0; screenPos.x *= aspect; screenPos.y *= -1.0; float minFOV = radians(20.0); float maxFOV = radians(120.0); float fov = mix(minFOV, maxFOV, uFov); vec3 rayDir = normalize(vec3(screenPos.x * tan(fov/2.0), screenPos.y * tan(fov/2.0), -1.0)); float rotX = (mousePos.y - 0.5) * PI; float rotY = (mousePos.x - 0.5) * PI * 2.0; mat3 rotateY = mat3( cos(rotY), 0.0, -sin(rotY), 0.0, 1.0, 0.0, sin(rotY), 0.0, cos(rotY) ); mat3 rotateX = mat3( 1.0, 0.0, 0.0, 0.0, cos(rotX), sin(rotX), 0.0, -sin(rotX), cos(rotX) ); return normalize(rotateX * rotateY * rayDir); }vec2 directionToUVHorizontal(vec3 dir) { float longitude = atan(dir.z, dir.x); float latitude = acos(dir.y); vec2 uv; uv.x = longitude / (2.0 * PI) + 0.5; uv.y = latitude / PI; uv.x += 0.25; return uv; }vec2 directionToUVVertical(vec3 dir) { float longitude = atan(dir.z, dir.y); float latitude = acos(dir.x); vec2 uv; uv.y = longitude / PI * -1.; uv.x = (latitude / (2.0 * PI) + 0.5) * -1.; uv.x = fract(uv.x + 0.25); return uv; }out vec4 fragColor;void main() { float aspect = 2.; vec2 mPos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000 * 0.5); vec3 rayDir = getRayDirection(vTextureCoord, mPos, aspect); vec2 uvHorizontal = directionToUVHorizontal(rayDir); vec2 uvVertical = directionToUVVertical(rayDir); vec2 sphereUV = mix(uvHorizontal, uvVertical, 0.0000); float minFOV = radians(20.0); float maxFOV = radians(120.0); float currentFOV = mix(minFOV, maxFOV, uFov); float fovCompensation = tan(currentFOV/2.0); float compensatedScale = (mix(-0.1, 0.4, uScale) * 12.0 + 2.0) * (1.0/fovCompensation); sphereUV = (sphereUV - 0.5) * compensatedScale + 0.5;sphereUV += vec2(0.23, 0) * uTime * 0.005; vec2 finalUV; if (0 == 0) { finalUV = sphereUV; } else if (0 == 1) { finalUV = vec2(fract(sphereUV.x), sphereUV.y); } else if (0 == 2) { finalUV = vec2(sphereUV.x, fract(sphereUV.y)); } else { finalUV = fract(sphereUV); } vec4 col = texture(uTexture, finalUV); fragColor = col;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{"scale":{"name":"uScale","type":"1f","value":0.5},"fov":{"name":"uFov","type":"1f","value":0.5}},"isBackground":false},"id":"effect3"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"circle","usesPingPong":false,"trackMouse":0,"mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float; in vec3 vVertexPosition; in vec2 vTextureCoord; uniform sampler2D uTexture; uniform vec2 uResolution;out vec4 fragColor;mat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); } void main() { vec2 uv = vTextureCoord; vec4 color = texture(uTexture, uv); float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114)); float displacement = (luma - 0.5) * 0.0000 * 0.5; vec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0); vec2 skew = vec2(0.4000, 1.0 - 0.4000); float halfRadius = 0.3000 * 0.5; float innerEdge = halfRadius - 1.0000 * halfRadius * 0.5; float outerEdge = halfRadius + 1.0000 * halfRadius * 0.5; vec2 pos = vec2(0.5, 0.5); const float TWO_PI = 6.28318530718; vec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew; vec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew; float radius = distance(scaledUV, scaledPos); float falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius); falloff = 1.0 - falloff; vec3 finalColor;finalColor = mix(color.rgb, mix(color.rgb, vec3(0.03529411764705882, 0.03529411764705882, 0.047058823529411764), 0.7500), falloff); color.rgb = finalColor; color.a = mix(1.0 - falloff, 1.0, 1.0000); fragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition; in vec2 aTextureCoord;uniform mat4 uMVMatrix; uniform mat4 uPMatrix; uniform mat4 uTextureMatrix;out vec2 vTextureCoord; out vec3 vVertexPosition;void main() { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy; }"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"effect4"}],"options":{"name":"Prod","fps":24,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":true},"version":"1.4.29","id":"upRCUN3bJt6OJ4mC2fC3"}